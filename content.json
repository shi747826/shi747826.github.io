{"meta":{"title":"SQRock","subtitle":null,"description":"菜是原罪","author":"SQRock","url":"https:shi747826.github.io"},"pages":[{"title":"","date":"2020-03-13T06:00:56.141Z","updated":"2020-03-13T05:56:59.657Z","comments":true,"path":"baidu_verify_qWVDxjC1F9.html","permalink":"https:shi747826.github.io/baidu_verify_qWVDxjC1F9.html","excerpt":"","text":"qWVDxjC1F9"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-01-22T09:27:03.907Z","comments":false,"path":"about/index.html","permalink":"https:shi747826.github.io/about/index.html","excerpt":"","text":"[SQRock] 与&nbsp; SQRock&nbsp; （ ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-01-21T08:48:26.388Z","comments":false,"path":"donate/index.html","permalink":"https:shi747826.github.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-01-21T08:48:26.388Z","comments":false,"path":"bangumi/index.html","permalink":"https:shi747826.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-01-21T08:48:26.388Z","comments":false,"path":"client/index.html","permalink":"https:shi747826.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-01-22T08:55:10.028Z","comments":true,"path":"comment/index.html","permalink":"https:shi747826.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-01-21T08:48:26.388Z","comments":true,"path":"rss/index.html","permalink":"https:shi747826.github.io/rss/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-01-22T11:16:45.968Z","comments":false,"path":"lab/index.html","permalink":"https:shi747826.github.io/lab/index.html","excerpt":"","text":"学生成绩综合管理系统","keywords":"Lab实验室"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-01-22T11:16:24.937Z","comments":true,"path":"tags/index.html","permalink":"https:shi747826.github.io/tags/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-01-22T08:56:16.627Z","comments":false,"path":"music/index.html","permalink":"https:shi747826.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-04-02T02:32:26.434Z","comments":true,"path":"links/index.html","permalink":"https:shi747826.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-01-30T08:50:56.255Z","comments":false,"path":"theme-sakura/index.html","permalink":"https:shi747826.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-01-22T11:04:36.200Z","comments":false,"path":"video/index.html","permalink":"https:shi747826.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 实验室 平时无聊鼓捣的小项目 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"STL","slug":"STL","date":"2020-04-03T07:43:35.000Z","updated":"2020-04-03T08:17:16.504Z","comments":true,"path":"2020/04/03/STL/","link":"","permalink":"https:shi747826.github.io/2020/04/03/STL/","excerpt":"","text":"#include 1.声明vector a;","categories":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https:shi747826.github.io/tags/STL/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}]},{"title":"Codeforces Round #629 (Div. 3)","slug":"Codeforces-Round-629-Div-3","date":"2020-03-27T05:58:27.000Z","updated":"2020-04-02T03:17:12.506Z","comments":true,"path":"2020/03/27/Codeforces-Round-629-Div-3/","link":"","permalink":"https:shi747826.github.io/2020/03/27/Codeforces-Round-629-Div-3/","excerpt":"","text":"A. Divisibility ProblemYou are given two positive integers a and b. In one move you can increase aa by 1 (replace a with a+1). Your task is to find the minimum number of moves you need to do in order to make a divisible by b. It is possible, that you have to make 0 moves, as a is already divisible by b. You have to answer t independent test cases. InputThe first line of the input contains one integer t (1 ≤ t ≤ 104) — the number of test cases. Then t test cases follow. The only line of the test case contains two integers a and b (1 ≤ a, b ≤ 109). OutputFor each test case print the answer — the minimum number of moves you need to do in order to make a divisible by b. Exampleinput 5 10 4 13 9 100 13 123 456 92 46 output 2 5 4 333 0 Problem solving题意就是给你两个整数a,b。a每次可以+1变成a+1,问a需要加多少次才可以变成b的倍数。 这道题只需要用b-a%b就行了。注意a可能本身就是b的倍数，所以最后需要再对b取模。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; inline void solve() { ll a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;(b - a % b) % b&lt;&lt;endl; } int main() { int T;cin&gt;&gt;T; while(T--) solve(); return 0; } B. K-th Beautiful StringFor the given integer n (n &gt; 2) let’s write down all the strings of length n which contain n−2 letters ‘a’ and two letters ‘b’ in lexicographical (alphabetical) order. Recall that the string s of length n is lexicographically less than string t of length n, if there exists such i (1 ≤ i ≤n), that s i &lt; t i , and for any j (1 ≤ j &lt; i) s i = t i. The lexicographic comparison of strings is implemented by the operator &lt; in modern programming languages. For example, if n=5 the strings are (the order does matter): aaabb aabab aabba abaab ababa abbaa baaab baaba babaa bbaaa It is easy to show that such a list of strings will contain exactly $\\frac{n⋅(n−1)}{2}$ strings. You are given n (n &gt; 2) and kk (1≤ k ≤ $\\frac{n·(n-1)}{2}$). Print the k-th string from the list. InputThe input contains one or more test cases. The first line contains one integer t (1 ≤ t ≤ 104) — the number of test cases in the test. Then t test cases follow. Each test case is written on the the separate line containing two integers n and k (3 ≤ n ≤ 105,1 ≤ k ≤ min(2⋅109, $\\frac{n⋅(n−1)}{2}$). The sum of values n over all test cases in the test doesn’t exceed 105. OutputFor each test case print the k-th string from the list of all described above strings of length n. Strings in the list are sorted lexicographically (alphabetically). Exampleinput 7 5 1 5 2 5 8 5 10 3 1 3 2 20 100 output aaabb aabab baaba bbaaa abb bab aaaaabaaaaabaaaaaaaa Problem solving题意是说给你一个n和k, 求用n-2个字符 ‘a’ 和2个字符 ‘b’ 进行全排列后字典序第k大的字符串。 因为 ‘a’ 的字典序比 ‘b’ 小，再根据样例可以看到，我们可以先找到第一个 ‘b’的位置，因为第一个 ‘b’ 的位置是有规律的，从倒数第二个开始，依次往左分别有1,2,3,4,5,6，…，i 个。所以我们可以用k依次减掉这些数，当k小于等于 i 时，就找到了第一个 ‘b’ 的位置p1。所以p1 = n - i; 然后第二个 ‘b’ 就有 n - i - 1个位置可以放。放的越靠后字典序越小。 #include&lt;bits/stdc++.h&gt; using namespace std; inline void solve() { int n,k; cin&gt;&gt;n&gt;&gt;k; int i; for(i=1;;i++) { if(k&lt;=i) break; k-=i; } int p1,p2; p1 = n-i; p2 = n-k+1; for(i=1; i&lt;=n; i++) if(i==p1 ||i==p2) cout&lt;&lt;&quot;b&quot;; else cout&lt;&lt;&quot;a&quot;; cout&lt;&lt;endl; } int main() { int T; cin&gt;&gt;T; while(T--) solve(); return 0; } C. Ternary XORA number is ternary if it contains only digits 00, 11 and 22. For example, the following numbers are ternary: 1022, 11, 21, 2002. You are given a long ternary number x. The first (leftmost) digit of x is guaranteed to be 2, the other digits of xx can be 0, 1 or 2. Let’s define the ternary XOR operation ⊙ of two ternary numbers aa and bb (both of length n) as a number c=a⊙b of length n, where ci=(ai+bi)%3 (where % is modulo operation). In other words, add the corresponding digits and take the remainders of the sums when divided by 3. For example, 10222⊙11021=21210. Your task is to find such ternary numbers aa and b both of length n and both without leading zeros that a⊙b=x and max(a,b) is the minimum possible. You have to answer t independent test cases. InputThe first line of the input contains one integer t (1 ≤ t ≤ 104) — the number of test cases. Then t test cases follow. The first line of the test case contains one integer n (1 ≤ n ≤ 5⋅104) — the length of x. The second line of the test case contains ternary number x consisting of n digits 0,1 or 2. It is guaranteed that the first digit of x is 2. It is guaranteed that the sum of n over all test cases does not exceed 5⋅104 (∑n ≤ 5⋅104). OutputFor each test case, print the answer — two ternary integers aa and bb both of length n and both without leading zeros such that a⊙b = x and max(a,b) is the minimum possible. If there are several answers, you can print any. Exampleinput 4 5 22222 5 21211 1 2 9 220222021 output 11111 11111 11000 10211 1 1 110111011 110111010 Problem solving题意中定义了一个三进制的异或规则(对应位上的数相加余3)，然后给你一个数x，让你输出两个数a,b，要保证这两个数的异或和等于x，并且这俩个数的最大值最小。即 ：a XOR b = x , max(a,b)尽可能小。 我们只需要单独分析每一位上的数即可。根据上面的异或规则，我们可以得出： 2 = 1 xor 1 或 0 xor 2 或 2 xor 0 (因为要保证尽可能小，所以a+b不应大于3) 1 = 0 xor 1 或 1 xor 0 0 = 0 xor 0 我们令a&gt;b。从左到右依次判断x的每一位， 如果还没分出大小：我们需要保证a,b尽量相同，即当x[i] = 2时，a[i]=b[i]=1；当x[i] = 0时，a[i]=b[i]=0。当x[i]=1时，a[i]=1，b[i]=0，这时无论后面怎么取值a已经大于b了; 如果已经分出了大小：只需要将a后面的全都补0，b后面照抄x就行了，这样就保证了大值a尽可能小。 #include&lt;bits/stdc++.h&gt; using namespace std; inline void solve() { int n; string s; cin&gt;&gt;n&gt;&gt;s; string a = &quot;1&quot;,b = &quot;1&quot;; int flag = 1; for(int i=1; i&lt;n; i++) { if(flag) { if(s[i] == &#39;2&#39;) a += &quot;1&quot;,b += &quot;1&quot;; if(s[i] == &#39;0&#39;) a += &quot;0&quot;,b += &quot;0&quot;; if(s[i] == &#39;1&#39;) a += &quot;1&quot;,b += &quot;0&quot;,flag = 0; } else { a += &quot;0&quot;; b += s[i]; } } cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b&lt;&lt;endl; } int main() { std::ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); int T; cin&gt;&gt;T; while(T--) solve(); return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https:shi747826.github.io/categories/算法/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https:shi747826.github.io/tags/codeforces/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https:shi747826.github.io/categories/算法/"}]},{"title":"Educational Codeforces Round 84 (Rated for Div. 2) C、E","slug":"Educational-Codeforces-Round-84-Rated-for-Div-2-C、E","date":"2020-03-24T02:10:59.000Z","updated":"2020-03-25T06:37:01.752Z","comments":true,"path":"2020/03/24/Educational-Codeforces-Round-84-Rated-for-Div-2-C、E/","link":"","permalink":"https:shi747826.github.io/2020/03/24/Educational-Codeforces-Round-84-Rated-for-Div-2-C、E/","excerpt":"","text":"C. Game with ChipsPetya has a rectangular Board of size n×m. Initially, k chips are placed on the board, i-th chip is located in the cell at the intersection of sxi-th row and syi-th column. In one action, Petya can move all the chips to the left, right, down or up by 11 cell. If the chip was in the (x, y) cell, then after the operation: left, its coordinates will be (x, y − 1); right, its coordinates will be (x, y + 1); down, its coordinates will be (x + 1, y); up, its coordinates will be (x − 1, y). If the chip is located by the wall of the board, and the action chosen by Petya moves it towards the wall, then the chip remains in its current position. Note that several chips can be located in the same cell. For each chip, Petya chose the position which it should visit. Note that it’s not necessary for a chip to end up in this position. Since Petya does not have a lot of free time, he is ready to do no more than 2nm actions. You have to find out what actions Petya should do so that each chip visits the position that Petya selected for it at least once. Or determine that it is not possible to do this in 2nm actions. InputThe first line contains three integers n, m, k (1 ≤ n, m, k ≤ 200) — the number of rows and columns of the board and the number of chips, respectively. The next k lines contains two integers each sxi, syi (1 ≤ sxi ≤ n,1 ≤ syi ≤ m) — the starting position of the i-th chip. The next kk lines contains two integers each fxi, fyi (1 ≤ fxi ≤ n, 1 ≤ fyi ≤ m) — the position that the i-chip should visit at least once. OutputIn the first line print the number of operations so that each chip visits the position that Petya selected for it at least once. In the second line output the sequence of operations. To indicate operations left, right, down, and up, use the characters L,R,D,U respectively. If the required sequence does not exist, print -1 in the single line. Examplesinput 3 3 2 1 2 2 1 3 3 3 2 output 3 DRD input 5 4 3 3 4 3 1 3 3 5 3 1 3 1 4 output 9 DDLUUUURR Problem solving题意就是在一个 n*m 的矩阵中给你 k 个点的起始位置和终止位置，让你输出一个长度小于 2nm 的字符串（只包括U,D,L,R，表示移动的方向，当移动到边界时就原地不动），这个字符串控制所有的k个点，让每个点都会至少经过一次自己对应的终止点。 这道题没有要求输出最小的字符串，所以可以直接让所有的起始点都置于矩阵的左上角，然后从左上角开始，到右下角，依次访问矩阵的每个点， #include&lt;bits/stdc++.h&gt; #define fi first #define se second #define pb push_back #define PI acos(-1) #define LC(a) ((a&lt;&lt;1)) #define RC(a) ((a&lt;&lt;1)+1) #define MID(a,b) ((a+b)&gt;&gt;1) #define mem(a, b) memset(a, b, sizeof(a)) #define IOS() std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0) using namespace std; typedef long long ll; typedef unsigned long long ULL; typedef pair&lt;int,int&gt; PII; typedef pair&lt;ll,ll&gt; PLL; typedef pair&lt;ll,int&gt; PLI; const int INF = 0X3F3F3F3F; const int MIN = -(1&lt;&lt;30); const ll N = 1e5+7; inline void solve() { int n,m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; int x,y; for(int i=0; i&lt;k; i++) cin&gt;&gt;x&gt;&gt;y;//与输入的起始点和终止点无关了 for(int i=0; i&lt;k; i++) cin&gt;&gt;x&gt;&gt;y; string s=&quot;&quot;; for(int i=n; i&gt;1; i--) s=s+&#39;U&#39;;//把所有点向上向左移到左上角 for(int j=m; j&gt;1; j--) s=s+&#39;L&#39;; for(int i=1; i&lt;=n; i++)//n行 { if(i&amp;1) //奇数行向右 for(int j=1; j&lt;m; j++) s=s+&#39;R&#39;; else //偶数行向左 for(int j=m; j&gt;1; j--) s=s+&#39;L&#39;; if(i!=n) s+=&#39;D&#39;; //除了最后一行 每行走到头的时候向下 } cout&lt;&lt;s.size()&lt;&lt;endl&lt;&lt;s&lt;&lt;endl; } int main() { IOS(); solve(); return 0; } E. Count The BlocksYou wrote down all integers from 0 to 10n − 1, padding them with leading zeroes so their lengths are exactly n. For example, if n = 3 then you wrote out 000, 001, …, 998, 999. A block in an integer x is a consecutive segment of equal digits that cannot be extended to the left or to the right. For example, in the integer 00027734000 there are three blocks of length 1, one block of length 2 and two blocks of length 3. For all integers i from 1 to n count the number of blocks of length i among the written down integers. Since these integers may be too large, print them modulo 998244353. InputThe only line contains one integer n (1 ≤ n ≤ 2⋅105). OutputIn the only line print n integers. The i-th integer is equal to the number of blocks of length i. Since these integers may be too large, print them modulo 998244353. Examplesinput 1 output 10 input 2 output 180 10 Problem solving题意让求的是从 0 到 10n - 1的这些数中（包括前导0，所以都是n位数）， 对应的每个长度i一共有多少个block。 block指的是连续相同的数字的长度，无法向左向右扩展。 例如：00027734000有2个长度为3的block，1个长度为2的block，3个长度为1的block. 可以理解为现在有n个空，每个空都可以插入0-9的一个数字，所有这些排列中长度为i的block有多少个。 因为所求的是长度为i的block，我们不妨直接插入一段长度为i的连续相等的一串数字，然后处理这串数字两端相邻的位置，让他们不与插入的数字相等即可。这里分两种情况： [ ] 插入的串两端都不在边界，插入的连续串可以为0-9，10种，两端相邻的位置不能和他相同，所以有9种。其他的位置可以随便，都是10种。而长度为i的串在n个为位置中有（n-i+1）个位置可以查入，减去两端的边界，就有（n-i-1)个位置可以插入。所以一共有：(n-i-1)$\\times$10$\\times$9$\\times$9$\\times$10 n-i-2 个block，n-i-2是剩余随便插的空格。 [ ] 插入的串两端有一端在边界。因为有一端在边界，所以只需要处理另一端不在边界的相邻位置就行了。这种情况有 2$\\times$10$\\times$9$\\times$10 n-i-1 个block，这里乘上2是因为有两个边界，不知道哪一端在边界上。 这两种情况加起来就是所求的block的个数了 #include&lt;bits/stdc++.h&gt; #define fi first #define se second #define pb push_back #define PI acos(-1) #define LC(a) ((a&lt;&lt;1)) #define RC(a) ((a&lt;&lt;1)+1) #define MID(a,b) ((a+b)&gt;&gt;1) #define mem(a, b) memset(a, b, sizeof(a)) #define IOS() std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0) using namespace std; typedef long long ll; typedef unsigned long long ULL; typedef pair&lt;int,int&gt; PII; typedef pair&lt;ll,ll&gt; PLL; typedef pair&lt;ll,int&gt; PLI; const int INF = 0X3F3F3F3F; const int MIN = -(1&lt;&lt;30); const ll N = 2e5+7; const ll mod = 998244353; ll fac[N]; ll ans[N]; inline void solve() { fac[0]=1; for(int i=1; i&lt;N; i++) fac[i] = fac[i-1]*10%mod; //把10的N次方预处理一下 ll n; cin&gt;&gt;n; ans[n] = 10; for(int i=n-1; i&gt;=1; i--) ans[i] = (((n-i-1)*10*9*9*fac[n-i-2])%mod + (10*9*2*fac[n-i-1])%mod)%mod; for(int i=1; i&lt;=n; i++) cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } int main() { IOS(); solve(); return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https:shi747826.github.io/categories/算法/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https:shi747826.github.io/tags/codeforces/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https:shi747826.github.io/categories/算法/"}]},{"title":"Codeforces Round #627 (Div. 3) D、E","slug":"Codeforces-Round-627-Div-3-D、E","date":"2020-03-12T15:25:23.000Z","updated":"2020-03-12T15:51:08.864Z","comments":true,"path":"2020/03/12/Codeforces-Round-627-Div-3-D、E/","link":"","permalink":"https:shi747826.github.io/2020/03/12/Codeforces-Round-627-Div-3-D、E/","excerpt":"","text":"D. Pair of TopicsThe next lecture in a high school requires two topics to be discussed. The i-th topic is interesting by ai units for the teacher and by bi units for the students. The pair of topics i and j (i &lt; j) is called good if ai + aj &gt; bi + bj (i.e. it is more interesting for the teacher). Your task is to find the number of good pairs of topics. InputThe first line of the input contains one integer n (2 ≤ n ≤ 2⋅105) — the number of topics. The second line of the input contains n integers a1,a2,…,an (1 ≤ ai ≤ 109), where ai is the interestingness of the i-th topic for the teacher. The third line of the input contains n integers b1,b2,…,bn (1 ≤ bi ≤ 109), where bi is the interestingness of the i-th topic for the students. OutputPrint one integer — the number of good pairs of topic. Examplesinput 5 4 8 2 6 2 4 5 4 1 3 output 7 input 4 1 3 2 4 1 3 2 4 output 0 Problem solving题意就是让你选出两个下标i , j，求符合ai + aj &gt; bi + bj 的有多少对。 可以直接让a减去b中下标相等的值，然后从大到小排序。 这样就变成从一个数组中挑选两个数和大于0的问题。 因为只选了两个下标，所以只需要先选一个，另外一个用二分查找就可以了。 #include&lt;bits/stdc++.h&gt; #define IOS() std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0) using namespace std; typedef long long ll; const ll N = 2e5+7; ll a[N]; ll cmp(ll a,ll b) { return a&gt;b; } inline void solve() { int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;n;i++) { ll x;cin&gt;&gt;x; a[i]-=x; } sort(a,a+n,cmp); ll ans = 0; for(int i=0;i&lt;n;i++) { if(a[i]&lt;=0) break; int l=i,r=n-1; while(l&lt;r) { int mid = (l+r+1)/2; if(a[i]+a[mid]&lt;=0) r=mid-1; else l = mid; } ans += l-i; } cout&lt;&lt;ans&lt;&lt;endl; } int main() { IOS(); solve(); return 0; } E. Sleeping ScheduleVova had a pretty weird sleeping schedule. There are h hours in a day. Vova will sleep exactly n times. The ii-th time he will sleep exactly after ai hours from the time he woke up. You can assume that Vova woke up exactly at the beginning of this story (the initial time is 00). Each time Vova sleeps exactly one day (in other words, h hours). Vova thinks that the ii-th sleeping time is good if he starts to sleep between hours l and r inclusive. Vova can control himself and before the ii-th time can choose between two options: go to sleep after ai hours or after ai − 1 hours. Your task is to say the maximum number of good sleeping times Vova can obtain if he acts optimally. InputThe first line of the input contains four integers n,h,l and r (1 ≤ n ≤ 2000,3 ≤ h ≤ 2000,0 ≤ l ≤ r &lt; h) — the number of times Vova goes to sleep, the number of hours in a day and the segment of the good sleeping time. The second line of the input contains n integers a1,a2,…,an(1 ≤ ai &lt; h), where ai is the number of hours after which Vova goes to sleep the ii-th time. OutputPrint one integer — the maximum number of good sleeping times Vova can obtain if he acts optimally. Exampleinput 7 24 21 23 16 17 14 20 20 11 22 output 3 Problem solving题意是说规定一天有h小时，每次睡觉都可以控制睡ai或者ai-1小时，经过n次后最多有多少次醒来的时间在 [l, r] 区间内。 DP 待补！","categories":[{"name":"算法","slug":"算法","permalink":"https:shi747826.github.io/categories/算法/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https:shi747826.github.io/tags/二分/"},{"name":"codeforces","slug":"codeforces","permalink":"https:shi747826.github.io/tags/codeforces/"},{"name":"DP","slug":"DP","permalink":"https:shi747826.github.io/tags/DP/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https:shi747826.github.io/categories/算法/"}]},{"title":"数据库作业3","slug":"数据库作业3","date":"2020-03-04T06:15:46.000Z","updated":"2020-03-04T07:08:58.229Z","comments":true,"path":"2020/03/04/数据库作业3/","link":"","permalink":"https:shi747826.github.io/2020/03/04/数据库作业3/","excerpt":"","text":"1.设学生选课数据库中包括三个表： 学生表：Student （Sno，Sname，Sex，Sage，Sdept） 课程表：Course（Cno，Cname，Ccredit） 学生选课表：SC（Sno，Cno，Grade） 其中Sno、Sname、Sex、Sage、Sdept、 Cno、Cname、Ccredit 、Grade分别表示学号、姓名、性别、年龄、所在系名、课程号、课程名、学分和成绩。假设上述三个表中已有若干条记录，用关系代数表示下列查询。 1） 查询年龄大于21的男生学号和姓名 $\\pi$Sno,Sname($\\sigma$Sage&gt;21,Sex=’男’ (Student)) 2) 查询选了“数据库”这门课的学生的学号。 $\\pi$Sno($\\sigma$Cname=’数据库’ (Coutse) $\\Join$ SC) 3) 查询“李强”同学不学课程的课程号。 Course - $\\pi$Cno,Cname,Ccredit($\\sigma$Sname=’李强’ (Student) $\\Join$ SC $\\Join$ Course) 4) 实现查询选修了全部课程的学生号码 $\\pi$Sno,Cno(SC) $\\div$ $\\pi$Cno(Course)","categories":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https:shi747826.github.io/tags/数据库/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}]},{"title":"数据库作业2","slug":"数据库作业2","date":"2020-02-24T04:49:21.000Z","updated":"2020-02-24T05:01:42.519Z","comments":true,"path":"2020/02/24/数据库作业2/","link":"","permalink":"https:shi747826.github.io/2020/02/24/数据库作业2/","excerpt":"","text":"解释下面的术语：1.数据与应用程序的逻辑独立性当模式改变时，由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性。 2.数据与应用程序的物理独立性当数据库的存储结构改变时，由数据库管理员对各个模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序的物理独立性。","categories":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https:shi747826.github.io/tags/数据库/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}]},{"title":"数据库第一章","slug":"数据库第一章","date":"2020-02-24T04:32:23.000Z","updated":"2020-02-24T04:36:27.534Z","comments":true,"path":"2020/02/24/数据库第一章/","link":"","permalink":"https:shi747826.github.io/2020/02/24/数据库第一章/","excerpt":"","text":"数据模型数据模型是对现实世界数据特征的抽象 三个抽象层次 [ ] 概念模型 [ ] 逻辑模型 [ ] 物理模型 概念模型 [ ] 实体：人事物或抽象的概念 [ ] 属性：实体具有的特性 [ ] 码（键、key、关键字） [ ] 实体性：实体名和其属性名的集合 [ ] 实体集：同一类实体的集合 [ ] 联系：实体内部的联系和实体之间的联系 [ ] 联系的类型 一对一(1:1) 一对多(1:n) 多对多(m:n) 概念模型的表示方法实体-联系（E-R） 数据模型的组成要素 [ ] 数据结构 [ ] 数据操作 [ ] 完整性约束 逻辑模型 [ ] 非关系模型 [ ] 关系模型 层次模型（树结构） [ ] 典型代表 1968IBM公司的IMS [ ] 采用的树形结构来表示各类实体及实体间的联系 层次数据模型的数据结构树形结构 表示方法 [ ] 实体型：用记录类型描述，每个结点表示一个记录类型 [ ] 属性：用字段描述。每个记录类型可包含若干个字段 [ ] 联系：用结点之间的连线表示， [ ] 层次数据库系统只能处理一对多的实体联系 层次模型的优缺点优点 简单清晰 缺点 不能多对多 网状模型（图结构）允许一个以上的结点没有双亲 一个结点可以有多于一个的双亲 多对多联系在网状模型中的表示 关系模型（二维表格） [ ] 关系 ：一个关系对应一个表 [ ] 元组： 表中的一行即为一个元组（不包括表头） [ ] 属性： 表中的每一列即为一个属性 [ ] 码：表中的某个属性或属性组，他可以唯一确定一个元组 [ ] 域：属性的取值范围 [ ] 分量： 元组中的一个属性值 [ ] 关系模式： 对关系的表述 关系名（属性1，属性2，…,属性n） 优缺点数据库系统的结构数据库系统模式的概念型和值型：对某一类数据的结构的属性和说明 值：是型的一个具体赋值 三级模式结构 数据库 —&gt; 内模式（1个） —&gt; 模式（1个） —&gt; 外模式（多个）—&gt;应用程序（多个） 模式（也称逻辑模式） [ ] 是数据库中全体数据的逻辑结构和特征的描述 [ ] 一个数据库只有一个模式 [ ] 模式位于数据库系统模式结构的中间层 模式的定义包括 数据的逻辑结构 数据之间的联系 [ ] 与数据有关的安全性、完整性要求 外模式 [ ] 数据库用户使用的局部数据的逻辑结构和特征的描述 [ ] 一个数据库可以用多个外模式 [ ] 外模式位于介于模式与应用之间 [ ] 模式与外模式 一对多 [ ] 模式与应用 一对多 内模式 [ ] 一个数据库只有一个内模式 [ ] 是数据物理结构电荷存储方式的描述 [ ] 是数据在数据库内部的组成方式 两层映像与数据独立性两层映像保证了DBS中的数据具有较高的逻辑独立性和物理独立性 外模式/模式映像 [ ] 定义外模式与模式之间的对应关系 [ ] 对于每一个外模式均有一个外模式/模式映像 [ ] 映像的定义通常包含在各自外模式的描述中 [ ] 用途：保证数据的逻辑独立性 模式/内模式映像 [ ] 定义了数据全局逻辑结构与存储结构之间的对应关系 [ ] 数据库中模式/内模式映像是唯一的 [ ] 该映像定义通常包含在模式描述中 [ ] 用途：保证数据的物理独立性 数据库系统的组成 [ ] 数据库 [ ] 数据库管理系统（及其开发工具） [ ] 应用系统 [ ] 数据库管理员 [ ] 用户 小结数据库系统的概述 [ ] 基本概念 [ ] 数据管理技术经历的发展阶段 数据模型 [ ] 数据模型的三要素 [ ] 概念模型（E-R模型） [ ] 三种主要的逻辑数据模型 数据库系统的结构 [ ] 数据库系统的三级模式和两层映像 [ ] 数据库系统的逻辑独立性和物理独立性 数据库系统的组成","categories":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https:shi747826.github.io/tags/数据库/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}]},{"title":"Codeforces Round #622 (Div. 2)","slug":"Codeforces-Round-622-Div-2","date":"2020-02-23T13:02:15.000Z","updated":"2020-02-23T14:50:35.856Z","comments":true,"path":"2020/02/23/Codeforces-Round-622-Div-2/","link":"","permalink":"https:shi747826.github.io/2020/02/23/Codeforces-Round-622-Div-2/","excerpt":"","text":"A. Fast Food RestaurantTired of boring office work, Denis decided to open a fast food restaurant. On the first day he made a portions of dumplings, b portions of cranberry juice and c pancakes with condensed milk. The peculiarity of Denis’s restaurant is the procedure of ordering food. For each visitor Denis himself chooses a set of dishes that this visitor will receive. When doing so, Denis is guided by the following rules: every visitor should receive at least one dish (dumplings, cranberry juice, pancakes with condensed milk are all considered to be dishes); each visitor should receive no more than one portion of dumplings, no more than one portion of cranberry juice and no more than one pancake with condensed milk; all visitors should receive different sets of dishes. What is the maximum number of visitors Denis can feed? InputThe first line contains an integer t (1 ≤ t ≤ 500) — the number of test cases to solve. Each of the remaining t lines contains integers a, b and c (0 ≤ a,b,c ≤ 10) — the number of portions of dumplings, the number of portions of cranberry juice and the number of condensed milk pancakes Denis made. OutputFor each test case print a single integer — the maximum number of visitors Denis can feed. Exampleinput7 1 2 1 0 0 0 9 1 7 2 2 3 2 3 2 3 2 2 4 4 4 output3 0 4 5 5 5 7 NoteIn the first test case of the example, Denis can feed the first visitor with dumplings, give the second a portion of cranberry juice, and give the third visitor a portion of cranberry juice and a pancake with a condensed milk. In the second test case of the example, the restaurant Denis is not very promising: he can serve no customers. In the third test case of the example, Denise can serve four visitors. The first guest will receive a full lunch of dumplings, a portion of cranberry juice and a pancake with condensed milk. The second visitor will get only dumplings. The third guest will receive a pancake with condensed milk, and the fourth guest will receive a pancake and a portion of dumplings. Please note that Denis hasn’t used all of the prepared products, but is unable to serve more visitors. Problem solving:题意就是有三种不同的食物，给出三种食物的数量，问有多少种食物搭配的方案（可以用1种、2种或3种食物进行搭配，只要没出现过就可以）。 很明显先从只选1种食物开始，如果当前数量大于1，方案数就加一。 然后从2种食物开始搭配，优先贪心选择剩余数量最多的两种，然后再乱搞（两两选择）。 最后如果3种食物数量都大于1，就可以再加一种方案（选择三种食物）。 #include&lt;bits/stdc++.h&gt; using namespace std; const ll N = 1e5+7; int main() { int t; cin&gt;&gt;t; while(t--) { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; int ans=0; if(a&gt;0) a--,ans++; if(b&gt;0) b--,ans++; if(c&gt;0) c--,ans++; int k[3]; k[0]=a; k[1]=b; k[2]=c; sort(k,k+3); if(k[2]&gt;0 &amp;&amp; k[1]&gt;0) k[2]--,k[1]--,ans++;//先选择最多的两个 //下面是乱搞的 if(k[0]&gt;0 &amp;&amp; k[2]&gt;0) k[0]--,k[2]--,ans++; if(k[1]&gt;0 &amp;&amp; k[0]&gt;0) k[1]--,k[0]--,ans++; if(k[1]&gt;0 &amp;&amp; k[0]&gt;0 &amp;&amp; k[2]&gt;0) ans++; cout&lt;&lt;ans&lt;&lt;endl; } return 0; } B. Different RulesNikolay has only recently started in competitive programming, but already qualified to the finals of one prestigious Olympiad. There going to be n participants, one of whom is Nikolay. Like any good Olympiad, it consists of two rounds. Tired of the traditional rules, in which the participant who solved the largest number of problems wins, the organizers came up with different rules. Suppose in the first round participant A took x-th place and in the second round — y-th place. Then the total score of the participant A is sum x + y. The overall place of the participant A is the number of participants (including A) having their total score less than or equal to the total score of A. Note, that some participants may end up having a common overall place. It is also important to note, that in both the first and the second round there were no two participants tying at a common place. In other words, for every i from 1 to n exactly one participant took i-th place in first round and exactly one participant took i-th place in second round. Right after the end of the Olympiad, Nikolay was informed that he got x-th place in first round and y-th place in the second round. Nikolay doesn’t know the results of other participants, yet he wonders what is the minimum and maximum place he can take, if we consider the most favorable and unfavorable outcome for him. Please help Nikolay to find the answer to this question. InputThe first line contains an integer t (1 ≤ t ≤ 100) — the number of test cases to solve. Each of the following t lines contains integers n, x, y (1 ≤ n ≤ 109, 1 ≤ x, y ≤ n) — the number of participants in the Olympiad, the place that Nikolay took in the first round and the place that Nikolay took in the second round. OutputPrint two integers — the minimum and maximum possible overall place Nikolay could take. Examplesinput1 5 1 3 output1 3 input1 6 3 4 output2 6 Problem solving:题意是说一共有n个人，有两轮比赛，你第一轮得了第a名。第二轮得了第b名。最后的总名次是按照这两次比赛和名次和来判断的，两轮的名次和越少总名次越高，问已知n,a,b的情况下，最好、最坏能得多少名。 注意两轮比赛中没有两人名次相同的情况，总名次会有相同的情况，例如5个人名次和分别是 4，4，4，8，10，那么这五个人的总名次就是3, 3, 3, 4, 5。 最坏情况就是总名次在你前面的人两轮的名次和都和你相同，这样最多会有a+b-1人（包括自己），而最多只有n人所以最坏情况就是min(n,a+b-1); 至于最好情况，感觉（乱搞）出来的 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int t; cin&gt;&gt;t; while(t--) { ll n,x,y; cin&gt;&gt;n&gt;&gt;x&gt;&gt;y; ll sum = x+y; //最好 if(sum&lt;n) cout&lt;&lt;1&lt;&lt;&quot; &quot;; else cout&lt;&lt;min(n,sum-n+1)&lt;&lt;&quot; &quot;; //最坏 cout&lt;&lt;min(n,sum-1)&lt;&lt;endl; } return 0; } C1. Skyscrapers (easy version)This is an easier version of the problem. In this version n ≤ 1000 The outskirts of the capital are being actively built up in Berland. The company “Kernel Panic” manages the construction of a residential complex of skyscrapers in New Berlskva. All skyscrapers are built along the highway. It is known that the company has already bought n plots along the highway and is preparing to build n skyscrapers, one skyscraper per plot. Architects must consider several requirements when planning a skyscraper. Firstly, since the land on each plot has different properties, each skyscraper has a limit on the largest number of floors it can have. Secondly, according to the design code of the city, it is unacceptable for a skyscraper to simultaneously have higher skyscrapers both to the left and to the right of it. Formally, let’s number the plots from 1 to n. Then if the skyscraper on the i-th plot has ai floors, it must hold that ai is at most mi (1 ≤ ai ≤ mi). Also there mustn’t be integers j and k such that j &lt; i &lt; k and aj &gt; ai &lt; ak . Plots j and k are not required to be adjacent to i. The company wants the total number of floors in the built skyscrapers to be as large as possible. Help it to choose the number of floors for each skyscraper in an optimal way, i.e. in such a way that all requirements are fulfilled, and among all such construction plans choose any plan with the maximum possible total number of floors. InputThe first line contains a single integer n (1 ≤ n ≤ 1000) — the number of plots. The second line contains the integers m1,m2,…,mn (1 ≤ mi ≤ 109) — the limit on the number of floors for every possible number of floors for a skyscraper on each plot. OutputPrint n integers ai — the number of floors in the plan for each skyscraper, such that all requirements are met, and the total number of floors in all skyscrapers is the maximum possible. If there are multiple answers possible, print any of them. Examplesinput5 1 2 3 2 1 output1 2 3 2 1 input3 10 6 8 output10 6 6 NoteIn the first example, you can build all skyscrapers with the highest possible height. In the second test example, you cannot give the maximum height to all skyscrapers as this violates the design code restriction. The answer [10,6,6] is optimal. Note that the answer of [6,6,8] also satisfies all restrictions, but is not optimal. Problem solving:题意是说给你一个序列，让你修改成 j &lt; i &lt; k 情况下没有 aj &gt; ai &lt; ak 的序列，要求修改后的序列和最大。修改时每个数不能超过原来的大小。 这道题因为是easy版本的 ，数据范围比较小，一般情况下就可以用暴力。 我们只需要暴力检查每个点，把当前点当做最大的，依次往两边扫就可以了。 #include&lt;bits/stdc++.h&gt; #define fi first #define se second #define PI acos(-1) #define LC(a) ((a&lt;&lt;1)) #define RC(a) ((a&lt;&lt;1)+1) #define MID(a,b) ((a+b)&gt;&gt;1) #define mem(a, b) memset(a, b, sizeof(a)) #define IOS() std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0) using namespace std; typedef long long ll; typedef unsigned long long ULL; typedef pair&lt;int,int&gt; PII; typedef pair&lt;ll,ll&gt; PLL; typedef pair&lt;ll,int&gt; PLI; const int INF = 0X3F3F3F3F; const int MIN = -(1&lt;&lt;30); const ll N = 1e5+7; int main() { IOS(); int n; cin&gt;&gt;n; ll a[1005]; ll b[1005]; ll c[1005]; ll mxi=0; for(int i=0; i&lt;n; i++) cin&gt;&gt;a[i]; ll ans=0; ll num; for(int mxi=0;mxi&lt;n;mxi++) { num = a[mxi]; b[mxi] = a[mxi]; for(int i=mxi-1; i&gt;=0; i--) { if(a[i]&gt;b[i+1]) b[i]=b[i+1]; else b[i] = a[i]; num+=b[i]; } for(int i=mxi+1; i&lt;n; i++) { if(a[i]&gt;b[i-1]) b[i]=b[i-1]; else b[i] = a[i]; num+=b[i]; } if(ans&lt;num) { ans=num; for(int i=0; i&lt;n; i++) c[i]=b[i]; } } for(int i=0; i&lt;n; i++) cout&lt;&lt;c[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; return 0; } C2. Skyscrapers (hard version)这道题和C1是一模一样的，只是n从1000增加到了500 000。 待补！","categories":[{"name":"算法","slug":"算法","permalink":"https:shi747826.github.io/categories/算法/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https:shi747826.github.io/tags/codeforces/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https:shi747826.github.io/categories/算法/"}]},{"title":"数据库作业1","slug":"数据库作业1","date":"2020-02-17T04:36:13.000Z","updated":"2020-02-17T04:52:00.234Z","comments":true,"path":"2020/02/17/数据库作业1/","link":"","permalink":"https:shi747826.github.io/2020/02/17/数据库作业1/","excerpt":"","text":"1.基本概念：DB、DBMS、DBSDB: 数据库（DataBase）是存放数据的仓库，是长期储存在计算机内、有组织的、可共享的大量数据的集合。 DBMS: 数据库管理系统 （DataBase Management System）是位于用户与操作系统之间的一层数据管理软件。 DBS: 数据库系统（DataBase System）由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员组成的储存、管理、处理和维护的系统。 2.DBMS的主要功能有哪些？(1) 数据定义功能 (定义数据库中的数据对象) (2) 数据组织、存储和管理 (文件结构、存取方式等) (3) 数据操纵功能 (增、删、改、查) (4) 数据库的食物管理和运行管理 (数据的安全性、完整性、并发控制、系统恢复) (5) 数据库的建立和维护功能 (数据输入、转储、恢复、性能监视) (6) 其他功能。 3.DBS的特点有哪些？(1) 数据结构化 (2) 数据的共享性高，冗余度底、易扩充 (3) 数据独立性高，（包括物理独立性和数据的逻辑独立性） (4) 数据由DBMS统一管理和控制。","categories":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https:shi747826.github.io/tags/数据库/"},{"name":"作业","slug":"作业","permalink":"https:shi747826.github.io/tags/作业/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}]},{"title":"2020牛客寒假算法基础集训营6 D-重排列","slug":"2020牛客寒假算法基础集训营6-D-重排列","date":"2020-02-15T09:35:07.000Z","updated":"2020-02-15T10:11:37.594Z","comments":true,"path":"2020/02/15/2020牛客寒假算法基础集训营6-D-重排列/","link":"","permalink":"https:shi747826.github.io/2020/02/15/2020牛客寒假算法基础集训营6-D-重排列/","excerpt":"","text":"D-重排列一个序列的重排列是指对这个序列中的元素进行若干次（包括0次）交换操作后得到的新序列 在本题中，序列中可能出现重复的数字，他们被视作不同的元素 例如，序列1 1的重排列有两种 现在有两个长度为 N 的非负整数序列 A 和 B，问有多少种 A 的重排列满足对于所有的 1 ≤ i ≤ N，有Ai ≤ Bi 由于答案可能很大，你只需要输出答案对1e9+7取模的结果 输入描述输入第一行，包含一个正整数 N 接下来一行，N 个非负整数表示序列 A 再接下来一行，N 个非负整数表示序列 B 1 ≤ N ≤ 105 0 ≤ Ai,Bi ≤109 输出描述一行一个整数，表示答案 示例：输入4 1 1 2 3 1 2 3 4 输出8 题解题意就是说数组A所以重排列中，有多少个满足所以的 i (1 ≤ i ≤ N)，有Ai ≤ Bi 。 这道题可以从大到小贪心选择数组A中的数，查找数组B中有多少个数是大于等于Ai的。 例如样例中的数据， [ ] A从3开始，B中有2个值大于等于3，说明3有2个位置可以选择。 [ ] 然后查找2，B中有3个值大于等于2，说明2有3个位置可以选择。但是上一步已经占了一个位置，所以需要减掉1，也就是有2个位置可以选择 [ ] 接着查找第一个1，B中4个值大于等于1，减掉前两个数占的位置，第一个1只有2个位置可以选择 [ ] 最后查找第二个1，B中4个值大于等于1，减掉前三个数占的位置，第二个1只剩1个位置可以选择 [ ] 最后 2 2 2 * 1 就是要求的结果了 因为需要查找数组B，可以将数组B排序后用二分来查找。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const ll N = 1e5+7; const ll mod = 1e9+7; ll a[N],b[N]; int cmp(ll a,ll b) { return a&gt;b; } int main() { ll n; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) cin&gt;&gt;a[i]; for(int j=0; j&lt;n; j++) cin&gt;&gt;b[j]; sort(a,a+n,cmp);//a数组从大到小排序 sort(b,b+n); ll ans = 1; for(ll i=0; i&lt;n; i++) { ll k = n-(lower_bound(b,b+n,a[i]) - b); //二分查找 //k存的是b数组中大于等于a[i]的数量，k-i即为可以选择的位置数量 ans=ans*(k-i&gt;0?k-i:0)%mod;//如果k&lt;=i 说明当前a[i]没有位置可以选择 } cout&lt;&lt;ans%mod&lt;&lt;endl; return 0; } 自己二分写的不熟，比赛中一直wa，搞不懂哪里错了，最后用了STL里的二分函数，还是wa。 然后无意的把ans*=(k-i&gt;0?k-i:0)%mod 改成了 ans=ans*(k-i&gt;0?k-i:0)%mod 一下就AC了，运算符优先级的问题，百度了一下看到 *=的优先级要比 % 优先级小得多，下次不会再偷懒了。","categories":[{"name":"算法","slug":"算法","permalink":"https:shi747826.github.io/categories/算法/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https:shi747826.github.io/tags/二分/"},{"name":"贪心","slug":"贪心","permalink":"https:shi747826.github.io/tags/贪心/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https:shi747826.github.io/categories/算法/"}]},{"title":"2020牛客寒假算法基础集训营4 C-子段乘积","slug":"2020牛客寒假算法基础集训营4-C-子段乘积","date":"2020-02-12T08:47:46.000Z","updated":"2020-02-12T09:26:55.407Z","comments":true,"path":"2020/02/12/2020牛客寒假算法基础集训营4-C-子段乘积/","link":"","permalink":"https:shi747826.github.io/2020/02/12/2020牛客寒假算法基础集训营4-C-子段乘积/","excerpt":"","text":"C.子段乘积给出一个长度为 n 的数列 a 1， a 2，a 3 . . . a n，求其长度为 k 的连续子段的乘积对 998244353 取模余数的最大值。 输入描述第一行两个整数n,k。 第二行n个整数,a 1， a 2，a 3 . . . a n。 1 &lt;= k &lt;= n &lt;= 2e5 0 &lt;= ai &lt; 998244353 输出描述输出一个整数，代表最大余数。 示例：输入5 3 1 2 3 0 8 输出6 说明1∗2∗3 mod 998244353 = 6 题解题意很简单，求的是区间为k的所有数之积 mod 998244353 的最大值是多少。暴力思路只用将所有长度为k的区间计算一遍纪录最大值就行了，这样时间复杂度为O（(n-k)*k）, 差不多就是O（n2)。 必然会超时。 正确做法是用线段树储存每个数，线段树查询的时间复杂度O（logn) ，总体来说就是O（nlogn)。 这道题也没有修改什么的，只需要建树，暴力区间查询就可以了。 #include&lt;bits/stdc++.h&gt; #define LC(a) ((a&lt;&lt;1)) #define RC(a) ((a&lt;&lt;1)+1) #define MID(a,b) ((a+b)&gt;&gt;1) #define IOS() std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0) using namespace std; typedef long long ll; const ll N = 2e5+7; const ll mod = 998244353; ll mx[N*4]; void build(int node,int l,int r) { if(l==r) { int x; cin&gt;&gt;x; mx[node]=x;//当数到达叶子节点输入存入值 return; } int mid = MID(l,r); build(LC(node),l,mid); build(RC(node),mid+1,r); mx[node] = mx[LC(node)] * mx[RC(node)] % mod;//父节点是两个子节点的乘积 mod 998244353 } ll query(int node,int st,int end,int l,int r) { if(end &lt; l || st &gt; r) return 1l; //如果递归到的区间与查询区间没有重合部分，返回1（因为是乘积） if(st &gt;= l &amp;&amp; end &lt;= r) return mx[node];//如果递归到的区间完全被查询区间包含，返回当前结点的值 ll lsum = query(LC(node),st,MID(st,end),l,r);//遍历左子树 ll rsum = query(RC(node),MID(st,end)+1,end,l,r);//遍历右子树 return lsum*rsum%mod;// } int main() { IOS(); int n,k; cin&gt;&gt;n&gt;&gt;k; build(1,1,n);//建树 ll ans = 0; for(int i=1,j=k;j&lt;=n;j++,i++) //尺取每个长度为k的区间 ans = max(ans,query(1,1,n,i,j)); cout&lt;&lt;ans&lt;&lt;endl; return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https:shi747826.github.io/categories/算法/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https:shi747826.github.io/tags/线段树/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https:shi747826.github.io/categories/算法/"}]},{"title":"Educational Codeforces Round 81 (Rated for Div. 2) B. Infinite Prefixes","slug":"Educational-Codeforces-Round-81-Rated-for-Div-2-B-Infinite-Prefixes","date":"2020-01-30T02:28:46.000Z","updated":"2020-01-30T03:59:59.066Z","comments":true,"path":"2020/01/30/Educational-Codeforces-Round-81-Rated-for-Div-2-B-Infinite-Prefixes/","link":"","permalink":"https:shi747826.github.io/2020/01/30/Educational-Codeforces-Round-81-Rated-for-Div-2-B-Infinite-Prefixes/","excerpt":"","text":"B. Infinite PrefixesYou are given string s of length n consisting of 0-s and 1-s. You build an infinite string t as a concatenation of an infinite number of strings s, or t = ssss… For example, if s = 10010, then t= 100101001010010... Calculate the number of prefixes of t with balance equal to x. The balance of some string q is equal to cnt0,q − cnt1,q, where cnt0,q is the number of occurrences of 0 in q, and cnt1,q is the number of occurrences of 1 in q. The number of such prefixes can be infinite; if it is so, you must say that. A prefix is a string consisting of several first letters of a given string, without any reorders. An empty prefix is also a valid prefix. For example, the string “abcd“ has 5 prefixes: empty string, “a“, “ab“, “abc“ and “abcd“. InputThe first line contains the single integer T (1 ≤ T ≤ 100)— the number of test cases. Next 2T lines contain descriptions of test cases — two lines per test case. The first line contains two integers n and x (1 ≤ n ≤ 105, −109 ≤ x ≤ 109) — the length of string s and the desired balance, respectively. The second line contains the binary string s (|s| = n, si ∈ {0,1}). It’s guaranteed that the total sum of n doesn’t exceed 105. OutputPrint T integers — one per test case. For each test case print the number of prefixes or −1 if there is an infinite number of such prefixes. Exampleinput4 6 10 010010 5 3 10101 1 0 0 2 0 01 output3 0 1 -1 NoteIn the first test case, there are 3 good prefixes of t: with length 28, 30 and 32. Problem solving:这场cf全是字符串，直接自闭。 题目意思是给你一个01字符串，然后这个字符串可以无限叠加。例如010010可以变成010010 010010、010010 010010 010010 010010 010010（串中没有空格） … 。然后找这个无限字符串的前缀，前缀0的个数减去1的个数等于x。问有多少种符合的前缀。 因为x有正负之分，需要判断的太多了，然后就把自己绕进去了。看了别人的代码后才知道可以先把负数的 x 变成正数，然后把原串01对换，这样就只需要判断正数的x了。 把原串 cnt0,q − cnt1,q 记为 num。 因为串是无穷的，所以会出现有无穷多个解的情况。当原串 num 等于 0 ，原串前缀的cnt0,q − cnt1,q等于x 时，答案就有无穷多个。输出 -1 当 num 不为 0 时 我用一个数组a记录原串中前缀当前位置的 cnt0,i − cnt1,i ,如下表所示： s = 010010 , x = 10 然后遍历这个数组，当 ( x - a[i] ) % num == 0 &amp;&amp; ( x - a[i] ) / num &gt;= 0 ） 时 答案ans就+1； 如表中 下标为2时 ，a[1] = 0，( x - a[i] ) % num == 0； ( x - a[i] ) / num = 5 。说明前缀包含了五个原串中，再加上第六个原串的前两个就可以满足 cnt0,q − cnt1,q = 10 当前位置为 5 * 6 + 2 即 32。 当下标为4时， ( x - a[i] ) / num = 4 ，我们可以得到在位置 4 * 6 + 4 即 28 处找到解。 当下标为6时， ( x - a[i] ) / num = 4 ，我们可以得到在位置 4 * 6 + 6 即 30 处找到解。 符合样例一。 AC代码： #include&lt;bits/stdc++.h&gt; #define fi first #define se second #define PI acos(-1) #define LC(a) ((a&lt;&lt;1)) #define RC(a) ((a&lt;&lt;1)+1) #define MID(a,b) ((a+b)&gt;&gt;1) #define mem(a, b) memset(a, b, sizeof(a)) #define IOS() std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0) using namespace std; typedef long long ll; typedef unsigned long long ULL; typedef pair&lt;int,int&gt; PII; typedef pair&lt;ll,ll&gt; PLL; typedef pair&lt;ll,int&gt; PLI; const int INF = 0X3F3F3F3F; const int MIN = -(1&lt;&lt;30); const ll N = 1e6+7; ll a[N]; int main() { IOS(); int t; cin&gt;&gt;t; while(t--) { ll n,x; string s; cin&gt;&gt;n&gt;&gt;x&gt;&gt;s; if(x&lt;0) { x=-x; for(int i=0; i&lt;n; i++) s[i]=s[i]==&#39;0&#39;?&#39;1&#39;:&#39;0&#39;; } // cout&lt;&lt;s&lt;&lt;endl; ll num=0; for(int i=0; i&lt;s.size(); i++) { if(s[i]==&#39;0&#39;) num++; else num--; a[i]=num; } ll ans=0; int flag = 0; if(num==0) { for(int i=0; i&lt;n; i++) { if(a[i]==x) flag=1; } } else { for(int i=0; i&lt;n; i++) { if((x-a[i])%num==0 &amp;&amp; (x-a[i])/num&gt;=0) ans++; } } if(x==0) ans++; if(flag) cout&lt;&lt;-1&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; } return 0; } 补题过程中我输出 -1 用了 puts,导致了不断地 Wrong answer on test 4 ，百度后才知道 关闭同步流 (std::ios::sync_with_stdio(false) )之后,不能再使用 scanf 、printf、gets、puts …。昨天有一道题换行用了endl也导致了wa，改用 ‘\\n’ 就 ac,难受了我好长时间。我决定以后慢慢地放弃cin、cout。 虽然它很香。","categories":[{"name":"算法","slug":"算法","permalink":"https:shi747826.github.io/categories/算法/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https:shi747826.github.io/tags/codeforces/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https:shi747826.github.io/categories/算法/"}]},{"title":"Codeforces Round #608 (Div. 2) B. Blocks","slug":"Codeforces-Round-608-Div-2-B-Blocks","date":"2020-01-28T06:26:39.000Z","updated":"2020-01-28T07:19:30.563Z","comments":true,"path":"2020/01/28/Codeforces-Round-608-Div-2-B-Blocks/","link":"","permalink":"https:shi747826.github.io/2020/01/28/Codeforces-Round-608-Div-2-B-Blocks/","excerpt":"","text":"B. BlocksThere are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. You may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). You want to find a sequence of operations, such that they make all the blocks having the same color. You don’t have to minimize the number of operations, but it should not exceed 3 ⋅ n. If it is impossible to find such a sequence of operations, you need to report it. InputThe first line contains one integer n (2 ≤ n ≤ 200) — the number of blocks. The second line contains one string s consisting of n characters, each character is either “W” or “B”. If the i-th character is “W”, then the i-th block is white. If the i-th character is “B”, then the i-th block is black. OutputIf it is impossible to make all the blocks having the same color, print −1. Otherwise, print an integer k (0 ≤ k ≤ 3⋅n) — the number of operations. Then print k integers p1,p2,…,pk (1≤pj≤n−1), where pj is the position of the left block in the pair of blocks that should be affected by the j-th operation. If there are multiple answers, print any of them. Examplesinput 8 BWWWWWWB output 3 6 2 4 input 4 BWBB output -1 input 5 WWWWW output 0 input 3 BWB output 2 2 1 NoteIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is “BWWWWBBB“. Then change blocks 2 and 3, so the sequence is “BBBWWBB“. And finally, change blocks 4 and 5, so all blocks are black. It is impossible to make all colors equal in the second example. All blocks are already white in the third example. In the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is “BBW“), and then change blocks 1 and 2 (so all blocks are white). Problem solving:这是一道div.2的B题，属于偏容易的题目。意思就是给你一串字符串，让你修改连续的两个字符的颜色，看最终是否能够把整个字符串变成完全一样的颜色（全白：W 或者全黑： B），比赛时被卡住了没地方下手，现在再看数据范围一点也不大，完全可以暴力，只需要check这个字符串能不能变成全白和全黑。for两次就可以了。 #include&lt;bits/stdc++.h&gt; #define fi first #define se second #define PI acos(-1) #define LC(a) ((a&lt;&lt;1)) #define RC(a) ((a&lt;&lt;1)+1) #define MID(a,b) ((a+b)&gt;&gt;1) #define mem(a, b) memset(a, b, sizeof(a)) #define IOS() std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0) using namespace std; typedef long long ll; typedef unsigned long long ULL; typedef pair&lt;int,int&gt; PII; typedef pair&lt;ll,ll&gt; PLL; typedef pair&lt;ll,int&gt; PLI; const int INF = 0X3F3F3F3F; const int MIN = -(1&lt;&lt;30); const ll N = 1e5+7; int n; string ss; vector&lt;int&gt; v,vv; int check(char ch) { string s = ss; for(int i=0; i&lt;s.size(); i++) { if(s[i]!=ch) { if(i+1==s.size()) return 0; ch==&#39;W&#39;?v.push_back(i):vv.push_back(i); s[i]=ch; s[i+1]=s[i+1]==&#39;W&#39;?&#39;B&#39;:&#39;W&#39;; // cout&lt;&lt;s&lt;&lt;endl; } } // cout&lt;&lt;s.size()&lt;&lt;endl; // for(auto it:v) // cout&lt;&lt;it+1&lt;&lt;&quot; &quot;; // cout&lt;&lt;endl; return 1; } int main() { IOS(); cin&gt;&gt;n&gt;&gt;ss; int flag1 = check(&#39;W&#39;); int flag2 = check(&#39;B&#39;); if(flag1 &amp;&amp; flag2) { if(v.size()&lt;vv.size()) { cout&lt;&lt;v.size()&lt;&lt;endl; for(auto it:v) cout&lt;&lt;it+1&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } else { cout&lt;&lt;vv.size()&lt;&lt;endl; for(auto it:vv) cout&lt;&lt;it+1&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } } else if(flag1) { cout&lt;&lt;v.size()&lt;&lt;endl; for(auto it:v) cout&lt;&lt;it+1&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } else if(flag2) { cout&lt;&lt;vv.size()&lt;&lt;endl; for(auto it:vv) cout&lt;&lt;it+1&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } else cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https:shi747826.github.io/categories/算法/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https:shi747826.github.io/tags/codeforces/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https:shi747826.github.io/categories/算法/"}]},{"title":" Mamba out","slug":"Mamba-out","date":"2020-01-27T00:38:20.000Z","updated":"2020-01-27T05:08:52.926Z","comments":true,"path":"2020/01/27/Mamba-out/","link":"","permalink":"https:shi747826.github.io/2020/01/27/Mamba-out/","excerpt":"","text":"今天一早起来刷朋友圈突然看到科比不幸去世，第一反应就是假的，然后又看了B乎、微博才接受这个事实。感觉就像在做梦，2020开局就炸裂？？？科比今年才41岁，还没等到科比生儿子，这个世界怎么了？愿天堂也有亲爱的篮球，R.I.P。","categories":[{"name":"生活","slug":"生活","permalink":"https:shi747826.github.io/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"https:shi747826.github.io/categories/生活/"}]},{"title":"我想被困在学校","slug":"我想被困在学校","date":"2020-01-26T09:06:58.000Z","updated":"2020-01-26T10:51:07.888Z","comments":true,"path":"2020/01/26/我想被困在学校/","link":"","permalink":"https:shi747826.github.io/2020/01/26/我想被困在学校/","excerpt":"","text":"昨天还想提前几天去学校呢，这是杀人诛心嘛？？？","categories":[{"name":"生活","slug":"生活","permalink":"https:shi747826.github.io/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"https:shi747826.github.io/categories/生活/"}]},{"title":"新年快乐","slug":"新年快乐","date":"2020-01-25T08:51:19.000Z","updated":"2020-01-25T10:01:31.256Z","comments":true,"path":"2020/01/25/新年快乐/","link":"","permalink":"https:shi747826.github.io/2020/01/25/新年快乐/","excerpt":"","text":"今天是大年初一，还有将近20天才开学，在家各种被家长嫌弃，好想去学校啊。希望河南灾情不要太严重，一定要按时开学啊啊啊。","categories":[{"name":"生活","slug":"生活","permalink":"https:shi747826.github.io/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"https:shi747826.github.io/categories/生活/"}]},{"title":"快速幂","slug":"快速幂","date":"2019-11-19T01:08:47.000Z","updated":"2020-01-26T04:32:27.274Z","comments":true,"path":"2019/11/19/快速幂/","link":"","permalink":"https:shi747826.github.io/2019/11/19/快速幂/","excerpt":"快速幂 ll ksm(ll a,ll n) { ll rec=1; while(n) { if(n&amp;1) rec=rec*a%mod; a=a*a%mod; n&gt;&gt;=1; } return rec%mod; }","text":"快速幂 ll ksm(ll a,ll n) { ll rec=1; while(n) { if(n&amp;1) rec=rec*a%mod; a=a*a%mod; n&gt;&gt;=1; } return rec%mod; } 快速乘+快速幂 ll ksc(ll x,ll y) //计算x乘y的积 { ll res=0;//加法初始化 while(y) { if(y&amp;1) res=(res+x)%mod;//模仿二进制 x=(x&lt;&lt;1)%mod; y&gt;&gt;=1;//将x不断乘2达到二进制 } return res; } ll ksmm(ll a,ll n) { ll rec=1; while(n) { if(n&amp;1) rec=ksc(rec,a)%mod; a=ksc(a,a)%mod; n&gt;&gt;=1; } return rec%mod; }","categories":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}],"tags":[{"name":"板子","slug":"板子","permalink":"https:shi747826.github.io/tags/板子/"},{"name":"数论","slug":"数论","permalink":"https:shi747826.github.io/tags/数论/"},{"name":"快速幂","slug":"快速幂","permalink":"https:shi747826.github.io/tags/快速幂/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}]},{"title":"素数筛","slug":"素数筛","date":"2019-11-19T01:06:42.000Z","updated":"2020-01-26T04:32:35.139Z","comments":true,"path":"2019/11/19/素数筛/","link":"","permalink":"https:shi747826.github.io/2019/11/19/素数筛/","excerpt":"","text":"typedef long long ll; const int N = 1e6+7; int v[N]; int prime[N]; int b[N]; void e_prime() { int k=0; memset(v,0,sizeof(v)); for(int i=2; i*i&lt;N; i++) { if(!v[i]) for(int j=i*i; j&lt;N; j+=i) v[j]=1; } for(int i=2; i&lt;N; i++) if(!v[i]) prime[k++]=i; }","categories":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}],"tags":[{"name":"板子","slug":"板子","permalink":"https:shi747826.github.io/tags/板子/"},{"name":"数论","slug":"数论","permalink":"https:shi747826.github.io/tags/数论/"},{"name":"素数","slug":"素数","permalink":"https:shi747826.github.io/tags/素数/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}]},{"title":"Kruskal模板","slug":"Kruskal模板","date":"2019-11-19T01:02:30.000Z","updated":"2020-01-26T04:32:05.813Z","comments":true,"path":"2019/11/19/Kruskal模板/","link":"","permalink":"https:shi747826.github.io/2019/11/19/Kruskal模板/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt; using namespace std; struct Edge { int x,y,len; } edge[500010]; int fa[100010],n,m,ans=0; bool operator &lt;(Edge a,Edge b) { return a.len&lt;b.len; } int find(int x) { return x==fa[x]?x:fa[x]=find(fa[x]); } int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=m; i++) cin&gt;&gt;edge[i].x&gt;&gt;edge[i].y&gt;&gt;edge[i].len; //按照边权排序 sort(edge+1,edge+m+1); //初始化并查集 for(int i=1; i&lt;=n; i++) fa[i]=i; //求最小生成树 for(int i=1; i&lt;=m; i++) { int x=find(edge[i].x); int y=find(edge[i].y); if(x==y) continue; fa[x]=y; ans+=edge[i].len; } cout&lt;&lt;ans&lt;&lt;endl; return 0; }","categories":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}],"tags":[{"name":"板子","slug":"板子","permalink":"https:shi747826.github.io/tags/板子/"},{"name":"MST","slug":"MST","permalink":"https:shi747826.github.io/tags/MST/"},{"name":"kruskal","slug":"kruskal","permalink":"https:shi747826.github.io/tags/kruskal/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}]},{"title":"Prim模板","slug":"Prim模板","date":"2019-11-19T00:56:06.000Z","updated":"2020-01-26T04:32:17.785Z","comments":true,"path":"2019/11/19/Prim模板/","link":"","permalink":"https:shi747826.github.io/2019/11/19/Prim模板/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt; using namespace std; // T:确定属于最小生成树的节点集合 // S:剩余节点集合 int a[3010][3010]; int d[3010];// d[x], x表示x加入T时选出的最小边的权值 bool vis[3010];// vis[x]==true表示该节点已经加入了T集合 int n,m,ans=0; void prim() { memset(d,0x3f,sizeof(d)); memset(vis,0,sizeof(vis)); d[1]=0; for(int i=1; i&lt;n; i++)//循环n-1次 每次找出一个点加入T { int x=0; for(int j=1; j&lt;=n; j++)//遍历所有节点 { //当前d[]数组存储的是各个节点距离生成树的最小权值 if(!vis[j] &amp;&amp; (x==0 || d[j]&lt;d[x])) //!vis[j]表示该节点尚未加入T集合 x=j; //选出距离生成树最近的节点 } vis[x]=1;//将该节点加入到生成树中(T集合) for(int y=1; y&lt;=n; y++) { if(!vis[y])//新加了一个点，就维护该点到还没有加入T集合的点的距离 d[y]=min(d[y],a[x][y]);//取距离生成树 } } } int main() { cin&gt;&gt;n&gt;&gt;m; //构建邻接矩阵 memset(a,0x3f,sizeof(a)); for(int i=1; i&lt;=n; i++) a[i][i]=0; for(int i=1; i&lt;=m; i++) { int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; a[x][y]=a[y][x]=min(a[x][y],z); } //求最小生成树 prim(); for(int i=2; i&lt;=n; i++) ans+=d[i]; cout&lt;&lt;ans&lt;&lt;endl; return 0; } /* 输入 输出15 6 10 1 2 6 1 3 1 1 4 5 2 3 5 2 5 3 3 4 5 3 5 6 3 6 4 4 6 2 5 6 6 */","categories":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}],"tags":[{"name":"板子","slug":"板子","permalink":"https:shi747826.github.io/tags/板子/"},{"name":"MST","slug":"MST","permalink":"https:shi747826.github.io/tags/MST/"},{"name":"Prim","slug":"Prim","permalink":"https:shi747826.github.io/tags/Prim/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}]},{"title":"Dijkstra模板","slug":"Dijkstra","date":"2019-11-18T12:19:18.000Z","updated":"2020-01-26T04:31:56.364Z","comments":true,"path":"2019/11/18/Dijkstra/","link":"","permalink":"https:shi747826.github.io/2019/11/18/Dijkstra/","excerpt":"普通版 int a[3010][3010],d[3010]; int n,m; bool v[3010]; void dijkstra() { memset(d,INF,sizeof(d)); memset(v,0,sizeof(v)); d[1]=0; for(int i=1; i&lt;n; i++) { int x=0; for(int j=1; j&lt;=n; j++) { if(!v[j] &amp;&amp; (x==0 || d[j]&lt;d[x])) x=j; } v[x]=1; for(int y=1; y&lt;=n; y++) if(!v[y]) d[y]=min(d[y],d[x]+a[x][y]); } }","text":"普通版 int a[3010][3010],d[3010]; int n,m; bool v[3010]; void dijkstra() { memset(d,INF,sizeof(d)); memset(v,0,sizeof(v)); d[1]=0; for(int i=1; i&lt;n; i++) { int x=0; for(int j=1; j&lt;=n; j++) { if(!v[j] &amp;&amp; (x==0 || d[j]&lt;d[x])) x=j; } v[x]=1; for(int y=1; y&lt;=n; y++) if(!v[y]) d[y]=min(d[y],d[x]+a[x][y]); } } 堆优化版 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 1000010; const int INF = 0x3f3f3f3f; int n,m; struct edge { int to; int r; } ; typedef pair&lt;int,int&gt; P; vector&lt;edge&gt; a[N]; int d[50005]; void dijkstra(int s) { priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt;que; memset(d,INF,sizeof(d)); d[s]=0; que.push(P(0,s)); while(que.size()) { P p=que.top(); que.pop(); int v=p.second; if(d[v]&lt;p.first) continue; for(int i=0; i&lt;a[v].size(); i++) { edge e=a[v][i]; if(d[e.to]&gt;d[v]+e.r) { d[e.to]=d[v]+e.r; que.push(P(d[e.to],e.to)); } } } } int main() { cin&gt;&gt;n&gt;&gt;m; int x,y,r; while(m--) { cin&gt;&gt;x&gt;&gt;y&gt;&gt;r; edge t1,t2; t1.to=y; t1.r=r; t2.to=x; t2.r=r; a[x].push_back(t1); a[y].push_back(t2); } dijkstra(1); for(int i=0; i&lt;=n; i++) cout&lt;&lt;d[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; return 0; }","categories":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}],"tags":[{"name":"板子","slug":"板子","permalink":"https:shi747826.github.io/tags/板子/"},{"name":"最短路","slug":"最短路","permalink":"https:shi747826.github.io/tags/最短路/"},{"name":"dijkstra","slug":"dijkstra","permalink":"https:shi747826.github.io/tags/dijkstra/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https:shi747826.github.io/categories/笔记/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2020-01-25T10:01:37.548Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"https:shi747826.github.io/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"https:shi747826.github.io/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https:shi747826.github.io/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https:shi747826.github.io/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https:shi747826.github.io/categories/技术/"}]}]}